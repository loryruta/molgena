from common import *
from rdkit import Chem
import networkx as nx
from collections import defaultdict
from gen_motif_vocab import *


def construct_motif_graph(mol_smiles: str, motif_vocab: pd.DataFrame) -> nx.Graph:
    """ Given a molecule and the motif vocabulary, construct the motif graph.
    The motif graph is a graph where nodes are motifs. """

    if motif_vocab.index.name != 'smiles':
        raise Exception("Motif vocabulary index should be \"smiles\" column")

    mol = Chem.MolFromSmiles(mol_smiles)

    for atom in mol.GetAtoms():
        atom.SetAtomMapNum(atom.GetIdx())

    atom_motif_map = defaultdict(set)  # Mol atom <-> Motif ID

    # Assign every mol atom to its motif ID
    candidates = extract_motif_candidates(Chem.MolToSmiles(mol))
    for candidate_idx, candidate in enumerate(candidates):
        motif_smiles = clear_atommap(candidate)
        is_motif = motif_smiles in motif_vocab.index
        if is_motif:
            # The candidate was a Motif as is (frequent enough in training set)
            motif_id = motif_vocab.loc[motif_smiles]['id']
            for atom in mol_from_smiles(candidate).GetAtoms():
                atom_motif_map[atom.GetAtomMapNum()].add(motif_id)
            logging.debug(f"{mol_smiles} motif: \"{motif_smiles}\"")
        else:
            # The candidate must have been split in bonds and rings
            motifs, _ = decompose_to_bonds_and_rings(candidate)
            for motif in motifs:
                motif_smiles = clear_atommap(motif)
                logging.debug(f"{mol_smiles} candidate motif \"{motif_smiles}\" decomposed to \"{motif_smiles}\"")
                assert motif_smiles in motif_vocab.index
                motif_id = motif_vocab.loc[motif_smiles]['id']
                for atom in mol_from_smiles(motif).GetAtoms():
                    atom_motif_map[atom.GetAtomMapNum()].add(motif_id)

    # Construct the motif graph
    motif_nx = nx.DiGraph()
    for bond in mol.GetBonds():
        atom_1 = bond.GetBeginAtomIdx()
        atom_2 = bond.GetEndAtomIdx()
        motif_set_1 = atom_motif_map[atom_1]  # List of motifs to which atom_1 takes part
        motif_set_2 = atom_motif_map[atom_2]  # List of motifs to which atom_2 takes part

        for motif_1 in motif_set_1:
            for motif_2 in motif_set_2:
                if motif_1 != motif_2:
                    # motif_1 -> motif_2, write attachment information on motif_2
                    if (motif_1, motif_2) not in motif_nx.edges:
                        motif_nx.add_edge(motif_1, motif_2, attachment={atom_2})
                    else:
                        motif_nx.edges[motif_1, motif_2]['attachment'].add(atom_2)

                    # motif_2 -> motif_1, write attachment information on motif_1
                    if (motif_2, motif_1) not in motif_nx.edges:  # Insert
                        motif_nx.add_edge(motif_2, motif_1, attachment={atom_1})
                    else:  # Update
                        motif_nx.edges[motif_2, motif_1]['attachment'].add(atom_1)
                motif_nx.add_node(motif_1)
                motif_nx.add_node(motif_2)
    return motif_nx


def _main():
    import matplotlib.pyplot as plt
    from rdkit.Chem import Draw

    dataset = pd.read_csv(DATASET_PATH)

    mol_smiles = dataset['smiles'].sample().iloc[0]
    motif_vocab = pd.read_csv(MOTIF_VOCAB_CSV, index_col=['smiles'])

    motif_nx = construct_motif_graph(mol_smiles, motif_vocab)

    logging.info(
        f"Motif graph constructed for \"{mol_smiles}\"; Nodes: {len(motif_nx.nodes)}, Edges: {len(motif_nx.edges)}")

    # Draw mol
    plt.axis('off')
    plt.imshow(Draw.MolToImage(mol_from_smiles(mol_smiles)))
    plt.text(5, -10, mol_smiles)
    plt.show()

    # Draw motifs generated by mol
    candidates = extract_motif_candidates(mol_smiles)  # TODO very used code; gather it somewhere else
    for candidate in candidates:
        if candidate in motif_vocab.index:
            motif_id = motif_vocab.loc[candidate]['id']
            plt.axis('off')
            plt.imshow(Draw.MolToImage(mol_from_smiles(candidate)))
            plt.text(5, -10, f"Motif ID {motif_id}\n\"{candidate}\"")
            plt.show()
        else:
            parts, _ = decompose_to_bonds_and_rings(candidate)
            for part in parts:
                motif_id = motif_vocab.loc[part]['id']
                plt.axis('off')
                plt.imshow(Draw.MolToImage(mol_from_smiles(part)))
                plt.text(5, -10, f"Motif ID {motif_id}\n\"{part}\"")
                plt.show()

    # Draw motif graph
    nx.draw(motif_nx, with_labels=True)
    plt.show()


if __name__ == "__main__":
    _main()
